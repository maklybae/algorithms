# Семинар 10: Бинарное дерево поиска

## ДЗ

## Задание 1

> Предположим, что бинарное дерево поиска $T$, в
котором хранится $1000$ уникальных элементов, также
является полным деревом. Поэтому, для хранения $T$
используется массив — индексы элементов дерева $T$
назначаются в порядке обхода в ширину, начиная с 0.
Определите индекс третьего наибольшего элемента.

Нам известно, что в полное дерево является идеальным, если число его вершин $2^{h + 1} - 1$, понимаем, что это не наш случай, то есть последний уровень данного дерева заполнен не полностью (помним, что полное дерево заполняется слева направо).

Сразу же найдем высоту дерева, получаем $h = 9$.

Исходя из этих рассуждений можем утверждать, что максимальный элемент --- самый "правый" (с наибольшим индексом в массиве вершин) элемент предпоследнего уровня, его индекс $2^{(h - 1) + 1} - 1 = 2^9 - 1 = 511$.

Так как нам нужно найти третий наибольший элемент, запустим алгоритм `FindPredecessor` два раза. Формальное описание алгоритма:

```c++
  static BinaryNode *FindPredecessor(BinaryNode *t) {
    if (!t) {
      return nullptr;
    }

    if (t->left) {
      return FindMax(t->left);
    }

    BinaryNode *parent{t->parent};
    while (parent && t == parent->left) {
      t = parent;
      parent = parent->parent;
    }

    return parent;
  }
```

Задаемся вопросом: есть ли у нашей максимальной вершины левый ребенок? Я утверждаю, что нет, так как его индекс в таком случае был бы $511 * 2 + 1 = 1023$, а всего у нас $1000$ элементов. Также очевидно, что "максимальная" вершина --- правый ребенок своего родителя, поэтому второй наибольший элемент --- это просто родитель вершины с индексом $511$, то есть $\left\lfloor\frac{511}{2}\right\rfloor = 255$ элемент.

Осталось проделать еще один шаг алгоритма `FindPredecessor`. Тут уже события развиваются по-другому, так как у второго максимума есть левый ребенок, поэтому искомый ответ --- максимум поддерева с корнем-левым ребенком текущей вершины (см. формальное описание алгоритма, так понятнее). Максимум поддерева --- самый правый его предок.

Сейчас мы находимся в вершине с индексом $255$, ныряем в левого ребенка, получаем $255 \cdot 2 = 510$. Тут два варианта: либо элемент с индексом $510$ является максимумом, либо максимум --- это его правый ребенок. Второй вариант отметается, так как в таком случае необходим элемент с индексом $510 \cdot 2 + 1 = 1021 > 1000$.

Теперь вспоминаем, что массив $0$-индексированный, поэтому ответом будет являться $510-1=509$.

## Задание 2

- [Реализация бинарного дерева и итераторов](bst/tree.h)
- [Набор тестов](bst/main.cpp)



