# Семинар 3

## ДЗ

### Упражнение 5.2

$$
T_A(n) = c_A n \log_{10}(n)
$$

$$
T_B(n) = c_B n
$$

Подставим данные из условия, чтобы найти константы $c_A$ и $c_B$

Для алгоритма A:

$$
c_A 10^{4} \log_{10}(10^{4}) = 100 \Rightarrow
c_A = \frac{10^2}{4 \cdot 10^4} = \frac{1}{400}
$$

Для алгоритма B:

$$
c_B 10^{4} = 500 \Rightarrow
c_B = \frac{500}{10^4} = \frac{1}{20}
$$

Зная константы, перепишем:

$$
T_A(n) = \frac{n \log_{10}(n)}{400}
$$

$$
T_B(n) = \frac{n}{20}
$$

***При каких размерах входных данных алгоритм В более эффективен?***

Тут просто нужно решить неравенство: $T_A(n) > T_B(n)$

$$
\frac{n \log_{10}(n)}{400} > \frac{n}{20} \Rightarrow \log_{10}(n) > 20 \Rightarrow n > 10^{20} + 1
$$

***Если практический размер входных данных не превышает $10^{9}$, какому алгоритму следует отдать предпочтение?***

Опираясь на предыдущий вопрос, стоит отдать предпочтение алгоритму $A$.

### Упражнение 6

```c++
void func(int n) {
    int i = 1, s = 1;
    while (s <= n) {
        ++i;
        s += i;
    }
}
```

Начальные замечания: функция считает сумму арифметической прогрессии с шагом $1$, цикл прерывается в тот момент, когда накапливаемая сумма $s$ становится больше заданного $n$.

Найдем такое $k$, что арифметическая прогрессия от 1 до $k$ с шагом $1$ не превышает заданного $n$.

$$
\frac{k(k + 1)}{2} ≤ n \Rightarrow k^{2} + k - 2n ≤ 0 \Rightarrow\\
\Rightarrow k ≤ \frac{-1 + \sqrt{1+8n}}{2}
$$

Тут считаем, что все числа неотрицательные целые, поэтому один корень квадратного уравнения "отпадает".

Из этого можно сделать вывод, что всего будет
$\left \lfloor {\frac{-1 + \sqrt{1+8n}}{2}} \right \rfloor$
вхождений в цикл и
$\left \lfloor {\frac{-1 + \sqrt{1+8n}}{2}} \right \rfloor + 1$
сравнений.

Учитывая это, легко можно составить функцию $T(n)$. Для простоты будем считать, что все присвоение, сравнение, и тд – одна элементарная операция.

$$
T(n) = 2 + 2 \left \lfloor {\frac{-1 + \sqrt{1+8n}}{2}} \right \rfloor + \left \lfloor {\frac{-1 + \sqrt{1+8n}}{2}} \right \rfloor + 1
$$

Нужно преобразовывать:

$$
T(n) = 3 + 3 \left \lfloor {\frac{-1 + \sqrt{1+8n}}{2}} \right \rfloor = \\
= O(1) + 3 \left \lfloor {\frac{-1}{2} + \frac{\sqrt{1+8n}}{2}} \right \rfloor ≤
O(1) + 3 \left( {\frac{-1}{2} + \frac{\sqrt{1+8n}}{2}} \right) =\\
O(1) + \frac{3}{2} \sqrt{1+8n}
$$

Дело остается за малым! Покажем, что $\sqrt{1+8n} = O(\sqrt{n})$

$$
\sqrt{1+8n} ≤ c \sqrt{n} \Rightarrow 1 + 8n ≤ c^{2}n \Rightarrow c ≥ \sqrt{\frac{1}{n} + 8}
$$

Ok, sooo let $c = 8$

Тогда

$$
T(n) = O(1) + \frac{3}{2} \sqrt{1+8n} = O(1) + O(\sqrt{n}) = O(\sqrt{n})
$$

### Домашнее задание

```c++
#include <iostream>
#include <vector>
#include <climits>

int long_find_max_sum(const std::vector<int>& arr, int k) {
    int n = arr.size();
    int max_sum = INT_MIN;
    for (int i = 0; i <= n - k; ++i) {
        int current_sum = 0;
        for (int j = i; j < i + k; ++j ) {
            current_sum += arr[j];
        }
        max_sum = std::max(max_sum, current_sum);
    }
    return max_sum;
}
```

Начальные замечания: функция находит наибольшую сумму подмассива размера $k$.

Для этого алгоритма достаточно легко написать функцию $T(n, k)$. Все также принимаем, что каждая атомарная операция – единица. Единственное, что здесь интересно, что функция $T$ зависит от двух переменных $n$ и $k$.

$$
\displaylines{
T(n, k) = 2 + (n - k + 2) + (n - k + 1) (3 + (k + 1) + k) =\\
= 4 + n - k + (n - k + 1)(2k + 4) =\\
= 4 + n - k + 2nk - 2k^{2} + 2k + 4n - 4k + 4 =\\
= 2nk - 2k^{2} - 3k + 5n + 8 =\\
= O(nk) +O(k^{2}) + O(k) + O(n) + O(1) }
$$

Докажем, что $O(k^2) = O(nk)$, учитывая, что $k <= n$, для произвольной $g(n)$

$$
g(n) ≤ c k^2 ≤ c n k \, \blacksquare 
$$

Итак,
$$
T(n, k) = O(nk)
$$

Определенно можно улучшить этот алгоритм. Заметим, что на каждом шаге мы суммируем все те же числа, кроме тех, что занимают крайние позиции. Это связано с тем, что каждый раз "окно" сдвигается на единицу.

```c++
#include <iostream>
#include <vector>
#include <climits>

int long_find_max_sum(const std::vector<int>& arr, int k) {
    int n = arr.size();
    int cur_sum{};
    int max_sum{INT_MIN};
    for (int i = 0; i < n; ++i) {
        cur_sum += arr[i];
        if (i >= k - 1) {
            max_sum = std::max(max_sum, cur_sum);
            cur_sum -= arr[i - k + 1];
        }
    }
    return max_sum;
}
```

Обсудим: первые $k - 1$ итераций цикла сумма еще не накоплена, другими словами, она не соответствует сумме чисел подмассива размером меньше $k$. Начиная с $k$-ой итерации можно уже сравнивать сумму на максимум и переприсваивать его. После "сдвигаем окно".

Обоснуем сложность этого алгоритма. Сделать это не очень то и сложно... 

$$
\displaylines{
T(n, k) = 3 + (n + 1) + (k - 1) + 5(n - k + 1) =\\
6n - 4k + 8 = O(n) + O(n) + O(1) = O(n) }
$$
